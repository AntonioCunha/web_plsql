// @flow

/*
*	Execute the Oracle proceduure
*/

const debug = require('debug')('oracleExpressMiddleware:procedure');
const _ = require('lodash');
const Database = require('./database');
const files = require('./files');

import type {oracledb$bindingType} from './database';
import type {oracleExpressMiddleware$options} from './index';
import type {filesUploadType} from './files';

/**
* Invoke the Oracle procedure and return the page content
*
* @param {string} procedure - The procedure to invoke.
* @param {Object} argObj - - The arguments of the procedure to invoke.
* @param {Object} cgiObj - The cgi of the procedure to invoke.
* @param {filesUploadType} filesToUpload - Array of files to be uploaded
* @param {oracleExpressMiddleware$options} options - the options for the middleware.
* @param {Database} database - Database instance.
* @returns {Promise<string>} - Promise resolving to the page content generated by the executed procedure
*/
async function invoke(procedure: string, argObj: Object, cgiObj: Object, filesToUpload: filesUploadType, options: oracleExpressMiddleware$options, database: Database): Promise<string> {
	debug('executeRequest: invoke');

	// Upload all files
	files.uploadFiles(filesToUpload, options.doctable, database);

	// Get the code to execute depending on a fixed or variable number of argumnent
	const code = (procedure.substring(0, 1) === '!') ? await getVarArgsPara(procedure, argObj) : await getFixArgsPara(procedure, argObj, database);

	// Invoke the procedure and return the page contents
	return await executeProcedure(code, cgiObj, options, database);
}

/*
* Get the sql statement and bindings for the procedure to execute for a variable number of arguments
*/
async function getVarArgsPara(procedure: string, argObj: Object): Promise<{sql: string, bind: oracledb$bindingType}> {
	debug('getVarArgsPara: start');

	const names = [];
	const values = [];

	_.forEach(argObj, (value, key) => {
		if (typeof value === 'string') {
			names.push(key);
			values.push(value);
		} else if (Array.isArray(value)) {
			value.forEach((item) => {
				names.push(key);
				values.push(item);
			});
		}
	});

	return Promise.resolve({
		sql: procedure.substring(1) + '(:argnames, :argvalues);',
		bind: {
			argnames: {dir: Database.BIND_IN, type: Database.STRING, val: names},
			argvalues: {dir: Database.BIND_IN, type: Database.STRING, val: values}
		}
	});
}

/*
* Get the sql statement and bindings for the procedure to execute for a fixed number of arguments
*/
async function getFixArgsPara(procedure: string, argObj: Object, database: Database): Promise<{sql: string, bind: oracledb$bindingType}> {
	debug('getFixArgsPara: start');

	const bind = {};
	let index = 0;

	const argTypes = await getArguments(procedure, database);

	// bindings for the statement
	let sql = procedure + '(';
	for (const key in argObj) {
		const value = argObj[key];
		const parameterName = 'p' + (index + 1).toString();

		// prepend the separator, if this is not the first argument
		if (index > 0) {
			sql += ',';
		}
		index++;

		// add the argument
		sql += key + '=>:' + parameterName;

		// add the binding
		bind[parameterName] = {dir: Database.BIND_IN, type: Database.STRING};

		// set the value or array of values
		if (Array.isArray(value) || argTypes[key] === 'PL/SQL TABLE') {
			bind[parameterName].val = [];
			if (typeof value === 'string') {
				bind[parameterName].val.push(value);
			} else {
				value.forEach((element) => {
					bind[parameterName].val.push(element);
				});
			}
		} else if (typeof value === 'string') {
			bind[parameterName].val = value;
		}
	}
	sql += ');';

	return Promise.resolve({
		sql: sql,
		bind: bind
	});
}

/*
*	Run the procedure where "procStatement" is the sql statement to execute and "procBindings" are the additional bindings to be added.
*/
async function executeProcedure(code: {sql: string, bind: oracledb$bindingType}, cgiObj: Object, options: oracleExpressMiddleware$options, database: Database): Promise<string> {
	debug('executeProcedure: start');

	const HTBUF_LEN = 63;
	const MAX_IROWS = 100000;

	const irows = MAX_IROWS;
	const sql = [];
	const bind = {};

	// BEGIN
	sql.push('BEGIN');

	// Ensure a stateless environment by resetting package state (dbms_session.reset_package)
	sql.push('dbms_session.modify_package_state(dbms_session.reinitialize);');

	// initialize the cgi
	const cgiKeys = Object.keys(cgiObj);
	if (cgiKeys.length > 0) {
		sql.push('owa.init_cgi_env(:cgicount, :cginames, :cgivalues);');
		bind.cgicount = {dir: Database.BIND_IN, type: Database.NUMBER, val: cgiKeys.length};
		bind.cginames = {dir: Database.BIND_IN, type: Database.STRING, val: cgiKeys};
		bind.cgivalues = {dir: Database.BIND_IN, type: Database.STRING, val: Object.values(cgiObj)};
	}

	// initialize the htp package
	sql.push('htp.init;');

	// set the HTBUF_LEN
	sql.push('htp.HTBUF_LEN := :htbuflen;');
	bind.htbuflen = {dir: Database.BIND_IN, type: Database.NUMBER, val: HTBUF_LEN};


	// execute the procedure
	sql.push('BEGIN');
	sql.push('   ' + code.sql);
	sql.push('EXCEPTION');
	sql.push('   WHEN OTHERS THEN');
	sql.push('      raise_application_error(-20000, \'Error executing ' + code.sql + '\'||CHR(10)||SUBSTR(dbms_utility.format_error_stack()||CHR(10)||dbms_utility.format_error_backtrace(), 1, 2000));');
	sql.push('END;');

	// retrieve the page
	sql.push('owa.get_page(thepage=>:page, irows=>:irows);');
	bind.page = {dir: Database.BIND_OUT, type: Database.STRING, maxSize: 100, maxArraySize: irows};
	bind.irows = {dir: Database.BIND_INOUT, type: Database.NUMBER, val: irows};

	// END
	sql.push('END;');

	// execute procedure and retrieve page
	const result = await database.execute(sql.join('\n'), Object.assign(bind, code.bind));

	// Make sure that we have retrieved all the rows
	if (result.outBinds.irows > MAX_IROWS) {
		return Promise.reject(new Error(`Unable to retrieve all rows. irows="${result.outBinds.irows}"`));
	}

	return result.outBinds.page.join('');
}

/*
*	Retrieve the argument types for a given procedure to be executed.
*	This is important because if the procedure is defined to take a PL/SQL indexed table,
*	we must provise a table, even if there is only one argument to be submitted.
*/
async function getArguments(procedure: string, database: Database): Promise<{[string]: string}> {
	debug(`getArguments: start "${procedure}"`);

	const sql = [
		'DECLARE',
		'	schemaName		VARCHAR2(32767);',
		'	part1			VARCHAR2(32767);',
		'	part2			VARCHAR2(32767);',
		'	dblink			VARCHAR2(32767);',
		'	objectType		NUMBER;',
		'	objectID		NUMBER;',
		'BEGIN',
		'	dbms_utility.name_resolve(name=>UPPER(:name), context=>1, schema=>schemaName, part1=>part1, part2=>part2, dblink=>dblink, part1_type=>objectType, object_number=>objectID);',
		'	IF (part1 IS NOT NULL) THEN',
		'		SELECT argument_name, data_type BULK COLLECT INTO :names, :types FROM all_arguments WHERE owner = schemaName AND package_name = part1 AND object_name = part2 AND argument_name IS NOT NULL ORDER BY overload, sequence;',
		'	ELSE',
		'		SELECT argument_name, data_type BULK COLLECT INTO :names, :types FROM all_arguments WHERE owner = schemaName AND package_name IS NULL AND object_name = part2 AND argument_name IS NOT NULL ORDER BY overload, sequence;',
		'	END IF;',
		'END;'
	];
	const MAX_PARAMETER_NUMBER = 1000;

	const bind = {
		name: {dir: Database.BIND_IN, type: Database.STRING, val: procedure},
		names: {dir: Database.BIND_OUT, type: Database.STRING, maxSize: 60, maxArraySize: MAX_PARAMETER_NUMBER},
		types: {dir: Database.BIND_OUT, type: Database.STRING, maxSize: 60, maxArraySize: MAX_PARAMETER_NUMBER}
	};

	const result = await database.execute(sql.join('\n'), bind);
	debug('getArguments: returned', result);

	const argTypes = {};
	if (typeof result !== 'object' || typeof result.outBinds !== 'object' || !Array.isArray(result.outBinds.names) || !Array.isArray(result.outBinds.types)) {
		return Promise.reject(new Error('getArguments: invalid results'));
	}

	for (let i = 0; i < result.outBinds.names.length; i++) {
		argTypes[result.outBinds.names[i].toLowerCase()] = result.outBinds.types[i];
	}

	return Promise.resolve(argTypes);
}

module.exports = invoke;
